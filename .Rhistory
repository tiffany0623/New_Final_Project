# fit to the test
best <- select_best(pokemon_turn_rf, metric = 'roc_auc')
final_test <- finalize_workflow(pokemon_rf_wf, best)
pokemon_final_fit <- fit(final_test, data = pokemon_test)
# Print the AUC value of the best-performing model on the testing set.
prediction <- augment(pokemon_final_fit, new_data = pokemon_test) %>%
select(type_1, .pred_class.pred_Bug, .pred_Fire,.pred_Grass,
.pred_Normal, .pred_Psychic, .pred_Water)
# Print the AUC value of the best-performing model on the testing set.
prediction <- augment(pokemon_final_fit, new_data = pokemon_test) %>%
select(type_1, .pred_class, .pred_Bug, .pred_Fire,.pred_Grass,
.pred_Normal, .pred_Psychic, .pred_Water)
accuracy(prediction, type_1, .pred_class)
# Print the ROC curves.
augment(pokemon_final_fit, new_data = pokemon_test) %>%
roc_curve(type_1, .pred_Bug, .pred_Fire, .pred_Grass, .pred_Normal,
.pred_Psychic,.pred_Water) %>%
autoplot()
# create and visualize a confusion matrix heat map.
augment(pokemon_final_fit, new_data = pokemon_test) %>%
conf_mat(truth = type_1, estimate = .pred_class)  %>%
autoplot(type = "heatmap")
# fit to the test
best <- select_best(pokemon_turn_rf, metric = 'roc_auc')
pokemon_final_test <- finalize_workflow(pokemon_rf_wf, best)
pokemon_final_fit <- fit(pokemon_final_test, data = pokemon_train)
# Print the AUC value of the best-performing model on the testing set.
prediction <- augment(pokemon_final_fit, new_data = pokemon_test) %>%
select(type_1, .pred_class, .pred_Bug, .pred_Fire,.pred_Grass,
.pred_Normal, .pred_Psychic, .pred_Water)
accuracy(prediction, type_1, .pred_class)
# Print the ROC curves.
augment(pokemon_final_fit, new_data = pokemon_test) %>%
roc_curve(type_1, .pred_Bug, .pred_Fire, .pred_Grass, .pred_Normal,
.pred_Psychic,.pred_Water) %>%
autoplot()
# create and visualize a confusion matrix heat map.
augment(pokemon_final_fit, new_data = pokemon_test) %>%
conf_mat(truth = type_1, estimate = .pred_class)  %>%
autoplot(type = "heatmap")
# Print the AUC value of the best-performing model on the testing set.
roc_auc(augment(pokemon_final_fit, new_data = pokemon_test), type_1, .pred_Bug, .pred_Fire,
.pred_Grass, .pred_Normal, .pred_Psychic, .pred_Water)
# Print the ROC curves.
augment(pokemon_final_fit, new_data = pokemon_test) %>%
roc_curve(type_1, .pred_Bug, .pred_Fire, .pred_Grass, .pred_Normal,
.pred_Psychic,.pred_Water) %>%
autoplot()
# create and visualize a confusion matrix heat map.
augment(pokemon_final_fit, new_data = pokemon_test) %>%
conf_mat(truth = type_1, estimate = .pred_class)  %>%
autoplot(type = "heatmap")
# Read the Pokemon data set into R
Pokemon <- read_csv(file = "Pokemon.csv")
head(Pokemon)
# Set things up
pokemon <- Pokemon %>%
# Use clean_names()
clean_names() %>%
# Filter out the rarer Pokémon types
filter(type_1 == "Bug" |
type_1 == "Fire" |
type_1 == "Grass" |
type_1 == "Normal" |
type_1 == "Water" |
type_1 == "Psychic") %>%
# Convert type_1 and legendary to factors
mutate(type_1 = factor(type_1)) %>%
mutate(legendary = factor(legendary)) %>%
mutate(generation = factor(generation))
pokemon
# Read the Pokemon data set into R
Pokemon <- read_csv(file = "Pokemon.csv")
head(Pokemon)
# Set things up
pokemon <- Pokemon %>%
# Use clean_names()
clean_names() %>%
# Filter out the rarer Pokémon types
filter(type_1 == "Bug" |
type_1 == "Fire" |
type_1 == "Grass" |
type_1 == "Normal" |
type_1 == "Water" |
type_1 == "Psychic") %>%
# Convert type_1 and legendary to factors
mutate(type_1 = factor(type_1)) %>%
mutate(legendary = factor(legendary)) %>%
mutate(generation = factor(generation))
pokemon
# Read the Pokemon data set into R
Pokemon <- read_csv(file = "Pokemon.csv")
head(Pokemon)
# Set things up
pokemon <- Pokemon %>%
# Use clean_names()
clean_names() %>%
# Filter out the rarer Pokémon types
filter(type_1 == "Bug" |
type_1 == "Fire" |
type_1 == "Grass" |
type_1 == "Normal" |
type_1 == "Water" |
type_1 == "Psychic") %>%
# Convert type_1 and legendary to factors
mutate(type_1 = factor(type_1)) %>%
mutate(legendary = factor(legendary)) %>%
mutate(generation = factor(generation))
head(pokemon)
# Do an initial split of the data
set.seed(0623)
pokemon_split <- initial_split(pokemon, prop = 0.7, strata = type_1)
pokemon_train <- training(pokemon_split)
pokemon_test <- testing(pokemon_split)
pokemon_split
dim(pokemon_train)
dim(pokemon_test)
# Do an initial split of the data
set.seed(0623)
pokemon_split <- initial_split(pokemon, prop = 0.7, strata = type_1)
pokemon_train <- training(pokemon_split)
pokemon_test <- testing(pokemon_split)
pokemon_split
dim(pokemon_train)
dim(pokemon_test)
# Set up a recipe to predict type_1
pokemon_recipe <- recipe(type_1 ~ legendary + generation + sp_atk + attack +
speed + defense + hp + sp_def, data = pokemon_train) %>%
# Dummy-code legendary and generation
step_dummy(legendary) %>%
step_dummy(generation) %>%
# Center and scale all predictors.
step_center(all_predictors()) %>%
step_scale(all_predictors())
pokemon_recipe
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
# Create a correlation matrix of the training set
pokemon_train%>%
select(where(is.numeric)) %>%
cor() %>%
corrplot(method = 'number')
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
knitr::opts_chunk$set(echo = TRUE,
results = 'markup',
fig.width = 4,
fig.height = 3,
fig.align = 'center',
message = F,
warning = F)
# packages
library(tidyverse)
library(tidymodels)
library(ISLR)
library(ISLR2)
library(ggplot2)
library(yardstick)
library(readr)
library(discrim)
library(poissonreg)
library(corrr)
library(corrplot)
library(glmnet)
library(dplyr)
library(rpart.plot)
library(vip)
library(randomForest)
library(xgboost)
library(ranger)
library(janitor)
library(RSQLite)
tidymodels_prefer()
# Read the Pokemon data set into R
Pokemon <- read_csv(file = "Pokemon.csv")
head(Pokemon)
# Set things up
pokemon <- Pokemon %>%
# Use clean_names()
clean_names() %>%
# Filter out the rarer Pokémon types
filter(type_1 == "Bug" |
type_1 == "Fire" |
type_1 == "Grass" |
type_1 == "Normal" |
type_1 == "Water" |
type_1 == "Psychic") %>%
# Convert type_1 and legendary to factors
mutate(type_1 = factor(type_1)) %>%
mutate(legendary = factor(legendary)) %>%
mutate(generation = factor(generation))
head(pokemon)
# Do an initial split of the data
set.seed(0623)
pokemon_split <- initial_split(pokemon, prop = 0.7, strata = type_1)
pokemon_train <- training(pokemon_split)
pokemon_test <- testing(pokemon_split)
pokemon_split
dim(pokemon_train)
dim(pokemon_test)
# Fold the training set using v-fold cross-validation, with v = 5. Stratify on the outcome variable
pokemon_fold <- vfold_cv(pokemon_train, v = 5, strata = type_1)
pokemon_fold
# Set up a recipe to predict type_1
pokemon_recipe <- recipe(type_1 ~ legendary + generation + sp_atk + attack +
speed + defense + hp + sp_def, data = pokemon_train) %>%
# Dummy-code legendary and generation
step_dummy(legendary) %>%
step_dummy(generation) %>%
# Center and scale all predictors.
step_center(all_predictors()) %>%
step_scale(all_predictors())
pokemon_recipe
# Create a correlation matrix of the training set
pokemon_train%>%
select(where(is.numeric)) %>%
cor() %>%
corrplot(method = 'number')
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
knitr::opts_chunk$set(echo = TRUE,
results = 'markup',
fig.width = 4,
fig.height = 3,
fig.align = 'center',
message = F,
warning = F)
# packages
library(tidyverse)
library(tidymodels)
library(ISLR)
library(ISLR2)
library(ggplot2)
library(yardstick)
library(readr)
library(discrim)
library(poissonreg)
library(corrr)
library(corrplot)
library(glmnet)
library(dplyr)
library(rpart.plot)
library(vip)
library(randomForest)
library(xgboost)
library(ranger)
library(janitor)
library(RSQLite)
tidymodels_prefer()
# Read the Pokemon data set into R
Pokemon <- read_csv(file = "Pokemon.csv")
head(Pokemon)
# Set things up
pokemon <- Pokemon %>%
# Use clean_names()
clean_names() %>%
# Filter out the rarer Pokémon types
filter(type_1 == "Bug" |
type_1 == "Fire" |
type_1 == "Grass" |
type_1 == "Normal" |
type_1 == "Water" |
type_1 == "Psychic") %>%
# Convert type_1 and legendary to factors
mutate(type_1 = factor(type_1)) %>%
mutate(legendary = factor(legendary)) %>%
mutate(generation = factor(generation))
head(pokemon)
# Do an initial split of the data
set.seed(0623)
pokemon_split <- initial_split(pokemon, prop = 0.7, strata = type_1)
pokemon_train <- training(pokemon_split)
pokemon_test <- testing(pokemon_split)
pokemon_split
dim(pokemon_train)
dim(pokemon_test)
# Fold the training set using v-fold cross-validation, with v = 5. Stratify on the outcome variable
pokemon_fold <- vfold_cv(pokemon_train, v = 5, strata = type_1)
pokemon_fold
# Set up a recipe to predict type_1
pokemon_recipe <- recipe(type_1 ~ legendary + generation + sp_atk + attack +
speed + defense + hp + sp_def, data = pokemon_train) %>%
# Dummy-code legendary and generation
step_dummy(legendary) %>%
step_dummy(generation) %>%
# Center and scale all predictors.
step_center(all_predictors()) %>%
step_scale(all_predictors())
pokemon_recipe
# Create a correlation matrix of the training set
pokemon_train%>%
select(where(is.numeric)) %>%
cor() %>%
corrplot(method = 'number')
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set("roc_auc"))
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
best_auc <- collect_metrics(pokemon_tune_res) %>%
arrange(desc(mean))
best_auc
# set up a decision tree model and workflow
pokemon_tree_model <- decision_tree() %>%
set_engine("rpart") %>%
set_mode("classification") %>%
set_args(cost_complexity = tune())
pokemon_wf <- workflow() %>%
add_model(pokemon_tree_model) %>%
add_recipe(pokemon_recipe)
pokemon_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)
pokemon_tune_res <- tune_grid(pokemon_wf,
resamples = pokemon_fold,
grid = pokemon_grid,
metrics = metric_set(roc_auc))
# fit and visualize the best-performing pruned decision tree with the training set
best_complexity <- select_best(pokemon_tune_res)
best_complexity
pokemon_tree_final <- finalize_workflow(pokemon_wf, best_complexity)
pokemon_tree_final_fit <- fit(pokemon_tree_final, data = pokemon_train)
pokemon_tree_final_fit %>%
extract_fit_engine() %>%
rpart.plot()
# set up a random forest model
pokemon_rf_model <- rand_forest() %>%
set_engine("ranger", importance = "impurity") %>%
set_mode("classification") %>%
set_args(mtry = tune(), trees = tune(), min_n = tune())
# set up a random forest workflow
pokemon_rf_wf <- workflow() %>%
add_model(pokemon_rf_model) %>%
add_recipe(pokemon_recipe)
# create a regular grid
pokemon_rf_grid <- grid_regular(mtry(range = c(2, 7)),
trees(range = c(10, 1000)),
min_n(range = c(2, 10)),
levels = 8)
# set up a random forest model
pokemon_rf_model <- rand_forest() %>%
set_engine("ranger", importance = "impurity") %>%
set_mode("classification") %>%
set_args(mtry = tune(), trees = tune(), min_n = tune())
# set up a random forest workflow
pokemon_rf_wf <- workflow() %>%
add_model(pokemon_rf_model) %>%
add_recipe(pokemon_recipe)
# create a regular grid
pokemon_rf_grid <- grid_regular(mtry(range = c(2,7)),
trees(range = c(10, 800)),
min_n(range = c(2, 10)),
levels = 8)
pokemon_turn_rf <- tune_grid(pokemon_rf_wf,
resamples = pokemon_fold,
grid = pokemon_rf_grid,
metrics = metric_set(roc_auc))
autoplot(pokemon_turn_rf)
?roc_auc
?function roc_auc
best_rf <- select_best(pokemon_turn_rf, metric='roc_auc')
rf_final <- finalize_workflow(pokemon_rf_wf, best_rf)
rf_final_fit <- fit(rf_final, data=pokemon_train)
rf_final_fit %>%
extract_fit_engine() %>%
vip()
# set up a boosted tree model
boost_spec <- boost_tree() %>%
set_engine("xgboost") %>%
set_args(trees = tune()) %>%
set_mode("classification")
# set up a boosted tree workflow
boost_wf <- workflow() %>%
add_model(boost_spec) %>%
add_recipe(pokemon_recipe)
# Create a regular grid
boost_grid <- grid_regular(trees(range = c(10, 2000)), levels = 10)
tune_boost <- tune_grid(
boost_wf,
resamples = pokemon_fold,
grid = boost_grid,
metrics = metric_set(roc_auc))
